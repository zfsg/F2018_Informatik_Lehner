\documentclass[10pt,a4paper]{scrartcl}

\usepackage[english]{babel}
\usepackage{glossaries}\usepackage[xindy]{imakeidx}

%Set to 0 for making without examples
%Set to 1 for making with examples
\gdef\conditionmacro{1}

%\newenvironment{example}{
%\ifnum\conditionmacro=1}
%{\fi}

\input{../Headerfiles/Packages}
\input{../Headerfiles/Titles}
\input{../Headerfiles/Commands}
\input{../Headerfiles/ENVIRONMENTS}
\graphicspath{{Pictures/}}
\parindent 0pt

\title{Informatics}
\author{GianAndrea MÃ¼ller}

\newtheorem{define}{Definition}

\makenoidxglossaries
\newglossaryentry{Algorithm}{name={Algorithm},description={An algorithm is a set of rules that defines a sequence of operations to get to the solution of a problem.}}
\newglossaryentry{Language}{name={Language},description={A programming language is a set of instructions for a computer that can be used to write programs that implement algorithms.}}
\newglossaryentry{Syntax}{name={Syntax},description={The syntax of a computer language is the set of rules that defines the combinations of symbols that are considered to be a correctly structured document or fragment in that language. Is a program grammatically correct?}}
\newglossaryentry{Semantics}{name={Semantics},description={The semantics of a computer language define how the language has to be interpreted. What is the meaning of a certain program?}}
\newglossaryentry{Editor}{name={Editor},description={A program that allows writing code. There exist powerful editors that can check syntactical correctness on the fly.}}
\newglossaryentry{Compiler}{name={Compiler},description={A compiler translates a program written in a programming language to machine code, such that it can be executed by the machine.}}
\newglossaryentry{Computer}{name={Computer},description={A computer is a device that is capable of executing machine code.}}
\newglossaryentry{Comments}{name={Comments},description={Comments document the implemented algorithm within the program for the reader. They are ignored by the compiler.}}
\newglossaryentry{IncDir}{name={Include Directives},description={Include directives specify the additional libraries used in a program.}}
\newglossaryentry{Main}{name={The main function},description={The main function exists in every cpp-program. It is unique and contains the all instructions necessary to execute the program.}}
\newglossaryentry{Statement}{name={Statement},description={Statements are the building blocks of a program. They are executed sequentially and end with a semicolon.}}
\newglossaryentry{Declaration}{name={Declaration},description={A declaration introduces a new name to the program.}}
\newglossaryentry{Definition}{name={Definition},description={A definition introduces a body to a name within the program.}}
\newglossaryentry{Initialization}{name={Initialization},description={An initialization introduces a value to a defined name and body.}}
\newglossaryentry{Literals}{name={Literals},description={Literals represent constant value within the program. They have a defined type and value.}}
\newglossaryentry{Variables}{name={Variables},description={Variables represent possibly changing values within the program. They have name, type, value and address.}}
\newglossaryentry{Objects}{name={Objects},description={Objects represent values in the computer memory. They have type, adress and value. They can be named, but can also be anonymous. Described less generally an object can be a variable, a data structure, a function, or a method.}}
\newglossaryentry{Expressions}{name={Expressions},description={Expressions represent calculations. They are a combination of values, literals, operators and functions. They are primary if they consist of a single name/literal. Otherwise they are compound. They have type and value.}}
\newglossaryentry{Lvalue}{name={Lvalue},description={An lvalue is a changeable expression that has an address.}}
\newglossaryentry{Rvalue}{name={Rvalue},description={An rvalue is an expression that is not an lvalue. An rvalue cannot be changed. Every lvalue can be used as an rvalue but not vice-versa.}}
\newglossaryentry{Operator}{name={Operator},description={An operator connects expressions to compound expressions. It specifies the expected operand in type and if it is an rvalue or an lvalue. Operators have an arity.}}
\newglossaryentry{Arity}{name={Arity},description={Arity is the number of arguments or operands an operator or a function takes. For example there exist unary and binary operators.}}
\newglossaryentry{Block}{name={Block},description={A block in c++ is a number of lines of code enclosed by curly brackets.}}

\begin{document}
\begin{multicols*}{4}
\maketitle
\tableofcontents
\end{multicols*}

\begin{multicols*}{2}

%Nice to know
\newcommand{\ntn}[1]{\textcolor{blue}{#1}}

\ifnum\conditionmacro=1
\section{How to...}

\subsection{\ntn{... use this summary}}

This summary is an overview of the functionality of \verb.C++. in connection with the informatics course for mechanical engineers. It covers the content of the lectures but also contains additional information.

To emphasize the connection to the lecture all chapters containing purely additional information are marked in blue.

\subsection{\ntn{... correct compilation errors}}

Read error messages, review basic syntax, look for the additional semicolon.

\subsection{\ntn{... correct runtime errors}}

Use a \easyurl{debugger}{https://www.visualstudio.com/de/thank-you-downloading-visual-studio/?sku=Community&rel=15}.

\subsection{... approach problems}

\begin{enumerate}
\item Define your problem.
\item Find your algorithm.
\item Code feature.
\item Compile.
\item \verb+goto+ 3.
\end{enumerate}

\subsection{... find more information}

\begin{itemize}
\item \easyurl{Comprehensive Tutorial}{https://www.tutorialspoint.com/cplusplus/index.htm}
\item \easyurl{User friendly documentation}{http://www.cplusplus.com}
\item \easyurl{Extensive technical documentation}{http://en.cppreference.com/w/}
\end{itemize}
\fi

%Add all entries to glossary even though unused
\glsaddall

\printnoidxglossary[sort=def,title={Terms},nonumberlist=true,nopostdot=true]

\section{\ntn{Nice to know}}

\subsection{\ntn{Preprocessor directives}}

Preprocessor directives are lines preceded by a \verb+#+. These lines are not program statements but directives for the preprocessor, thus are evaluated before the program is compiled.
These preprocessor directives extend only across a single line of code. As soon as a newline character is found, the preprocessor directive is ends. No semicolon (;) is expected at the end of a preprocessor directive. The only way a preprocessor directive can extend through more than one line is by preceding the newline character at the end of the line by a backslash (\textbackslash).

\subsubsection{\ntn{Macro Definitions}}

\begin{TPCpp}
#define identifier replacement
\end{TPCpp}

When the preprocessor encounters this directive it replaces any occurrence of \verb+identifier+ in the rest of the code by \verb+replacement+. A macro lasts until it is undefined with \verb+#undef+. As seen in the following example it is also possible to define functions:

\begin{TPCpp}
//A simple constant
#define TABLE_SIZE 100
int table1 [TABLE_SIZE];
#undef TABLE_SIZE //lasts until here

//A function
#define getmax(a,b) a>b?a:b

int main(){
	int x = 5, y;
	y = getmax(x,2); //replaced as: y = x>2?x:2
}

}
\end{TPCpp}

This would replace any occurrence of \verb+getmax+ followed by two arguments by the replacement expression, but also replace each identifier by its respective argument.

\begin{TPCpp}
#define str(x) #x

cout<<str(test); // replaced as: cout<<"test";
\end{TPCpp}

As seen above an identifier preceded by \verb+#+ will be replaced by the argument in double quotes.

\begin{TPCpp}
#define glue(a,b) a ## b
glue(c,out) << "test"; //replaced as: cout << "test";
\end{TPCpp}

The operator \verb+##+ concatenates two arguments leaving no white space between them.

\subsubsection{\ntn{Conditional inclusions}}

The directives \verb+#ifdef+, \verb+#ifndef+, \verb+#if+, \verb+#endif+, \verb+#else+ and \verb+#elif+ allow to include or discard part of the code if a certain condition is met.

\verb+#ifdef+ allows a section of a program to be compiled only if the macro that is specified as the parameter has been defined, no matter which its value is. \verb+#endif+ ends the conditional block.

\begin{TPCpp}
#ifdef TABLE_SIZE
int table[TABLE_SIZE];
#endif
\end{TPCpp}

\verb+#ifndef+ serves for the exact opposite: the code between \verb+#ifndef+ and \verb+#endif+ directives is only compiled if the specified identifier has not been defined yet.

\begin{TPCpp}
#ifndef TABLE_SIZE
#define TABLE_SIZE 100
#endif
int table[TABLE_SIZE];
\end{TPCpp}

The \verb+#if+, \verb+#else+ and \verb+#elif+ directives serve to specify some condition to be met in order for the portion of code they surround to be compiled. The condition that follows \verb+#if+ and \verb+#elif+ can only evaluate constant expressions, including macro expressions.

\begin{TPCpp}
#if TABLE_SIZE>200
#undef TABLE_SIZE
#define TABLE_SIZE 200

#elif TABLE_SIZE<50
#undef TABLE_SIZE
#define TABLE_SIZE 50

#else
#undef TABLE_SIZE
#define TABLE_SIZE 100
#endif

int table[TABLE_SIZE];
\end{TPCpp}

Notice that the compelling advantage of preprocessor directives over normal conditional statements is that preprocessor directives are evaluated before the code is compiled. An interesting application of that concept is the making of different versions of a program, for instance one version that has special debugging precautions and a second version which runs faster but omits these safety measures.

\subsubsection{\ntn{Line control}}

 When we compile a program and some error happens during the compiling process, the compiler shows an error message with references to the name of the file where the error happened and a line number, so it is easier to find the code generating the error.

The \verb+#line+ directive allows us to control both things, the line numbers within the code files as well as the file name that we want that appears when an error takes place.

\begin{TPCpp}
//#line number "filename"

#line 20 "assigning variable"
int a?;
\end{TPCpp}

This code will generate an error that will be shown as error in file \verb+"assigning variable", line 20+.

\subsubsection{\ntn{Error directive}}

The \verb+#error+ directive aborts the compilation process when it is found, generating a compilation error that can be specified as its parameter.

\begin{TPCpp}
#ifndef _cplusplus
#error A C++ compiler is required!
#endif
\end{TPCpp}

\subsubsection{\ntn{Source file inclusion}}

The \verb+#include+ directive is replace by the entire content of the specified header or file. There are two ways to use \verb+#include+:

\begin{TPCpp}
#include <header>
#include "file"
\end{TPCpp}

In the first case, a header is specified between angle-brackets $<>$. This is used to include headers provided by the implementation, such as the headers that compose the standard library (iostream, string,...). Whether the headers are actually files or exist in some other form is implementation-defined, but in any case they shall be properly included with this directive.

The syntax used in the second \verb+#include+ uses quotes, and includes a file. The file is searched for in an implementation-defined manner, which generally includes the current path. In the case that the file is not found, the compiler interprets the directive as a header inclusion, just as if the quotes (``'') were replaced by angle-brackets ($<>$).

\subsubsection{\ntn{Pragma directive}}

This directive is used to specify diverse options to the compiler. These options are specific for the platform and the compiler you use. Consult the manual or the reference of your compiler for more information on the possible parameters that you can define with \verb+#pragma+.

\subsubsection{\ntn{Predefined macro names}}

\begin{TTable}[1]{lp{0.7\linewidth}}
\verb+__LINE__+&	Integer value representing the current line in the source code file being compiled.\\
\verb+__FILE__+&	A string literal containing the presumed name of the source file being compiled.\\
\verb+__DATE__+&A string literal in the form ``Mmm dd yyyy'' containing the date in which the compilation process began.\\
\verb+__TIME__+&A string literal in the form ``hh:mm:ss'' containing the time at which the compilation process began.\\
\verb+__cplusplus+&An integer value. All C++ compilers have this constant defined to some value. Its value depends on the version of the standard supported by the compiler.\\
\end{TTable}

\section{Positional Notation}

\subsection{Binary numbers}

\subsubsection{Floating point numbers}

\subsection{Hexadecimal numbers}

\section{Syntax}

\subsection{Basic program}

\begin{TPCpp}
#include <iostream>
//#include "local_header_file.h"

/*
 * Function declarations (and definitions)
 */

int main(int argc, char ** argv)
{
	  /*
	   * Function calls
	   */
    std::cout << "Hello World!" << std::endl;
    return 0;
}

/*
 * Function definitions
 */
\end{TPCpp}

\subsection{Identifiers}

A valid identifier, i.e. the name of a variable is:

\begin{itemize}
\item an arbitrarily long sequence of digits, underscores, lowercase and uppercase Latin letters.
\item not starting with a digit.
\item not starting with two or more underscores.
\item not starting with an underscore followed by a capital letter.
\item not a \easyurl{keyword}{http://en.cppreference.com/w/cpp/keyword} of cpp.
\end{itemize}

\ifnum\conditionmacro=1
More information on \easyurl{Identifiers}{http://en.cppreference.com/w/cpp/language/identifiers}.
\fi

\subsection{Comments}

C++ allows masking code such that it is not interpreted as part of the program. This enables documenting the program. There are different possibilities:

\begin{TPCpp}
// normal comment

/*
multi
line
comment
*/
\end{TPCpp}

Both versions can be nested:

\begin{TPCpp}
///*comment in a comment*/

/*
cout<<"Hello World!<<endl; //comment in a comment
*/
\end{TPCpp}

\subsection{Data Types}

\subsubsection{Primitive Types}

\ifnum\conditionmacro=1
\begin{TTable}[1]
{ll}
Type&Keyword\\\midrule
Boolean&bool\\
Character&char\\
Integer&int\\
Floating point&float\\
Double floating point&double\\
Valueless&void\\
\end{TTable}
\fi

\subsubsection{Type modifiers}

\ifnum\conditionmacro=1
There exist a number of type modifiers:

\begin{TTable}[1]
{ll}
Modifier&Effect\\\midrule
signed&variable interpreted as signed\\
unsigned&variable interpreted as unsigned\\
short&half number of allocated bits if possible\\
long&double number of allocated bits if possible\\
\end{TTable}

Based on the primitive types and their modifiers the spectrum of available types can be established. Their sizes differ depending on compiler and environment.
\fi

\begin{TTable}[1]
{llc}
Modifier&Typical Bit Width&Typical Range\\\midrule
char&1byte&-127 to 127\\
unsigned char&1byte&0 to 255\\
signed char&1byte&-127 to 127\\
int&4byte&-2'147'483'648 to 2'147'483'647\\
unsigned int&4bytes&0 to 4'294'967'295\\
signed int&4bytes&-2'147'483'648 to 2'147'483'647\\
short int&2bytes&-32'768 to 32'767\\
unsigned short int&2bytes&0 to 65'535\\
signed short int&2bytes&-32'768 to 32'767\\
long int&4bytes&-2'147'483'648 to 2'147'483'647\\
signed long int&4bytes&-2'147'483'648 to 2'147'483'647\\
unsigned long int&4bytes&0 to 4'294'967'295\\
float&4bytes&+/- 3.4e +/- 38 (~7 digits)\\
double&8bytes&+/- 1.7e +/- 308 (~15 digits)\\
long double&8bytes&+/- 1.7e +/- 308 (~15 digits)\\
\end{TTable}

\ifnum\conditionmacro=1
\subsubsection{\ntn{Find type sizes on your system}}
\begin{TPCpp}
#include <iostream>
using namespace std;

int main() {
   cout<< "Size: char : "<<sizeof(char)<<endl;
   cout<< "Size: int : "<<sizeof(int)<<endl;
   cout<< "Size: short int : "<<sizeof(short int)<<endl;
   cout<< "Size: long int : "<<sizeof(long int)<<endl;
   cout<< "Size: float : "<<sizeof(float)<<endl;
   cout<< "Size: double : "<<sizeof(double)<<endl;
   
   return 0;
}
\end{TPCpp}
\fi

\subsubsection{Type qualifiers: const \ntn{volatile restrict}}
%const volatile restrict

\begin{TTable}{lp{0.7\linewidth}}
\verb+const+&Objects of type \verb+const+ cannot be changed by the program during execution.\\
\verb+volatile+&The modifier \verb+volatile+ tells the compile that a variable's value may be changed in ways not explicitly specified by the program. (Imagine for instance manually changing the position of a switch on a microprocessor.)\\
\verb+restrict+&A pointer qualified by \verb+restrict+ is initially the only means by which the object it points to can be accessed.\\
\end{TTable}

\subsubsection{\ntn{Storage classes}}
%auto register static extern mutable

A storage class defines the scope (visibility) and life-time of variables and/or functions within a C++ Program. These specifiers precede the type that they modify.

\paragraph{\ntn{auto}}

The auto storage class is the default storage class for all local variables.

\paragraph{\ntn{register}}

The register storage class is used to define local variables that should be stored in a register instead of RAM. This means that the variable has a maximum size equal to the register size (usually one word) and can't have the unary '\&' operator applied to it (as it does not have a memory location).

The register should only be used for variables that require quick access such as counters. It should also be noted that defining 'register' does not mean that the variable will be stored in a register. It means that it MIGHT be stored in a register depending on hardware and implementation restrictions.

\paragraph{\ntn{static}}

The static storage class instructs the compiler to keep a local variable in existence during the life-time of the program instead of creating and destroying it each time it comes into and goes out of scope. Therefore, making local variables static allows them to maintain their values between function calls.

The static modifier may also be applied to global variables. When this is done, it causes that variable's scope to be restricted to the file in which it is declared.

In C++, when static is used on a class data member, it causes only one copy of that member to be shared by all objects of its class.

\paragraph{\ntn{extern}}

The extern storage class is used to give a reference of a global variable that is visible to ALL the program files. When you use 'extern' the variable cannot be initialized as all it does is point the variable name at a storage location that has been previously defined.

When you have multiple files and you define a global variable or function, which will be used in other files also, then extern will be used in another file to give reference of defined variable or function. Just for understanding extern is used to declare a global variable or function in another file.

The extern modifier is most commonly used when there are two or more files sharing the same global variables or functions as explained below.

\paragraph{\ntn{mutable}}

The mutable storage class only applies to non-static class members of non-reference and non-const type. When a class member is declared mutable it can be changed by const member functions.

\subsubsection{Variable Definition}

A variable definition tells the compiler where and how much storage to create for the variable. A variable definition specifies a data type and name. Type has to be either a primitive type or a user defined object. Multiple names can be introduced at once if separated by commas.

\begin{TPCpp}
int i,j,k;
\end{TPCpp}

This line both declares and defines the variables i,j and k.
Direct initialization is also possible:

\begin{TPCpp}
int d = 3, f = 2;
\end{TPCpp}

\textbf{If a variable is left uninitialized its value is undefined in general}. However, variables with static storage duration are implicitly set to 0.

\subsubsection{\ntn{Variable Declaration}}

It is possible to declare a variable without defining it. The declaration is accepted during compilation but has to be fitted with a definition at the time of linking of the program. This means that if a program consists of multiple files you can declare your variable wherever you need it but only define it once, since multiple definitions of the same variable are prohibited.

\begin{TPCpp}
//Variable declaration
extern int a,b; //Compiler knows that the variable exists

//Variable definition
int a,b; //Compiler knows that the variable exists
         //And allocates the storage space needed
\end{TPCpp}

\subsubsection{\ntn{typedef} and using}

You can create a new name for an existing type with \verb+using+ or \verb+typedef+:

\begin{TPCpp}
//typedef type newname;

typedef unsigned int uint;

//using newname = type;

using uchar = unsigned char;

uint a = 3; //a is an unsigned int

uchar b = '2'; //b is an unsigned char
\end{TPCpp}

\subsubsection{\ntn{union}}

A union is a special class type that can hold only one of its non-static data members at a time. The union is only as big as necessary to hold its largest data member. The other data members are allocated in the same bytes as part of that largest member. The details of that allocation are implementation-defined, and it's undefined behavior to read from the member of the union that wasn't most recently written.

\subsubsection{\ntn{enum}}

An enumerated type declares an optional type name and a set of zero or more identifiers that can be used as values of the type. This can improve readability of the code as values are given meaning.

\begin{TPCpp}
//enum enum-name {list of names} var-list;

enum day {mon, tue, wed, thu, fri, sat, sun} today;
today = mon; //today == 0
today = sun; //today == 6
\end{TPCpp}

The values assigned to the names start with zero and increment by default. But you can also directly assign values:

\begin{TPCpp}
enum color {red, green = 5, blue};
color c;
c = red;    //c == 0
c = green;  //c == 5
c = blue;   //c == 6
\end{TPCpp}

\section{Variable Scope}

A scope is a region of the program within which variable definitions persist. There are three types of scopes:

\begin{enumerate}
\item Inside a function or a block (local variables)
\item In the definition of function parameters (formal parameters)
\item Outside of all functions (global parameters)
\end{enumerate}

\subsection{Local Variables}

Variables that are defined within a function or a block can only be used by statements within that same function or block.

\begin{TPCpp}
for(int i = 0; i<3; i++){ //scope of the variable i
	std::cout<<i<<" ";
} //end of scope

// std::cout<<i; will result in error
\end{TPCpp}

\ifnum\conditionmacro=1

A variable can be redefined within a block. In that case the ``closer'' definition is used.

\begin{TPCpp}
int i = 5;
{
	int i = 3;
	std :: cout << i; // outputs 3
}
std :: cout << i; // outputs 5
\end{TPCpp}
\fi

\subsection{\ntn{Global Variables}}

Global variables are defined outside of all the functions, usually on top of the program. They will hold their value throughout the life-time of your program. This also mean that all functions within your program can access these variables.

\ifnum\conditionmacro=1

Including global variables the case of maximum complication, however undesired, is the following:

\begin{TPCpp}
#include <iostream>
using namespace std;

int i = 2;

void fun(){
	cout<<i;
}

int main(){
	int i = 5;
	{
		int i = 3;
		std :: cout << i;   // outputs 3
	}
	std :: cout << i;     // outputs 5
	fun();                // outputs 2
}
\end{TPCpp}
\fi

\section{Literals}

\subsection{Integer Literals}

An integer literal can be a binary, decimal, octal or hexadecimal constant. A prefix specifies the base: \verb+0b+ for binary, \verb+0+ for octal, \verb+0x+ for hexadecimal and nothing for decimal.

An integer literal can also have a suffix that is a combination of u (unsigned) and l (long).

\ifnum\conditionmacro=1
\begin{TPCpp}
212     // Decimal number
212ul   // Long unsigned decimal number
0xFeeL  // Long hexadecimal number
0b101   // Binary representation of 5
011     // Octal representation of 9
078     // Illegal: 8 is not an octal digit
\end{TPCpp}
\fi

\subsection{Floating-point Literals}

A floating point literal has an integer part, a decimal point, a fraction part and an exponent part. You can represent floating point literals either in decimal form or exponential form.

While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.

\ifnum\conditionmacro=1
\begin{TPCpp}
3.14195      // Decimal representation of pi
314195E-5L   // Exponential representation of pi
510E         // Illegal: incomplete exponent
210f         // Illegal: no decimal or exponent
.e55         // Illegal: missing integer or fraction
\end{TPCpp}
\fi

\subsection{Boolean Literals}

There are two Boolean literals and the are part of standard C++ keywords: \verb+true+ and \verb+false+.

\ifnum\conditionmacro=1
\begin{TPCpp}
bool a = true;
cout<<a; //outputs 1
a = false;
cout<<a; //outputs 0
bool = some_integer; //true for some_integer != 0
\end{TPCpp}
\fi

The conversion from integer to bool results in \verb+true+ for all nonzero values and in \verb+false+ for zero.

\subsection{Character Literals}

Character literals are enclosed in single quotes ('). A character literal can be a plain character ('x'), an escape sequence ('\verb+\t+') or a universal character ('\verb+\u02C0+').

\begin{TTable}[1]{ll}
\verb+\\+&\verb+\\+ character\\
\verb+\'+&' character\\
\verb+\"+&'' character\\
\verb+\?+&? character\\
\verb+\a+&Alert or bell\\
\verb+\b+&Backspace\\
\verb+\f+&Form feed\\
\verb+\n+&Newline\\
\verb+\r+&Carriage return\\
\verb+\t+&Horizontal tab\\
\verb+\v+&Vertical tab\\
\end{TTable}

\subsection{String Literals}

String literals are enclosed in double quotes. A string contains any combination of plain characters escape sequences and universal characters.

\section{Operators}

\subsection{Arithmetic Operators}

\begin{TTable}{lp{0.8\linewidth}}
\verb.+.&Adds two operands\\
\verb.-.&Subtracts the second operand from the first\\
\verb.*.&Multiplies both operands\\
\verb./.&Divides the first operand by the second\\
\verb.%.&Returns the remainder of an integer division of the two operators\\
\verb.++.&Increases an integer value by one\\
\verb.--.&Decreases an integer value by one\\
\end{TTable}

\subsection{Relational Operators}

\begin{TTable}{lp{0.8\linewidth}}
\verb.==.&Checks if the values of two operands are equal or not, if yes then condition becomes true.\\
\verb.!=.&Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.\\
\verb.>.&Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.\\
\verb.<.&Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.\\
\verb.>=.&Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.\\
\verb.<=.&Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.\\
\end{TTable}

\subsection{Logical Operators}

\begin{TTable}{lp{0.8\linewidth}}
\verb.&&.&Called Logical AND operator. If both the operands are non-zero, then condition becomes true.\\
\verb.||.&Called Logical OR Operator. If any of the two operands is non-zero, then condition becomes true.\\
\verb.!.&Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true, then Logical NOT operator will make false.\\
\end{TTable}

\subsection{\ntn{Bitwise Operators}}

Bitwise operators work on bits and perform bit-by-bit operations. The truth tables for bitwise AND \verb.&., bitwise OR \verb.|. and bitwise exclusive OR (XOR) \verb.^. are:

\begin{TTable}{*{5}{c}}
\verb.p.&\verb.q.&\verb.p&q.&\verb.p|q.&\verb.p^q.\\
0&0&0&0&0\\
0&1&0&1&1\\
1&1&1&1&0\\
1&0&0&1&1\\
\end{TTable}

\begin{TTable}{lp{0.8\linewidth}}
\verb.&.&Binary AND Operator copies a bit to the result if it exists in both operands.\\
\verb.|.&Binary OR Operator copies a bit if it exists in either operand.\\
\verb.^.&Binary XOR Operator copies the bit if it is set in one operand but not both.\\
\verb.~.&Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.\\
\verb.<<.&Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.\\
\verb.>>.&Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.\\
\end{TTable}

\subsection{Assignment Operators}

\begin{TTable}{lp{0.8\linewidth}}
\verb.=.&Simple assignment operator, Assigns values from right side operands to left side operand.\\
\verb.+=.&Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand.\\
\verb.-=.&Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand.\\
\verb.*=.&Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand.\\
\verb./=.&Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand.\\
\verb.%=.&Modulus AND assignment operator, It takes modulus using two operands and assign the result to left operand.\\
\end{TTable}

\subsection{\ntn{Assignment Operators}}

\begin{TTable}{lp{0.8\linewidth}}
\verb.<<=.&Left shift AND assignment operator.\\
\verb.>>=.&Right shift AND assignment operator.\\
\verb.&=.&Bitwise AND assignment operator.\\
\verb.^=.&Bitwise exclusive OR and assignment operator.\\
\verb.|=.&Bitwise inclusive OR and assignment operator.\\
\end{TTable}

\subsection{Misc Operators}

\begin{TTable}{lp{0.8\linewidth}}
\verb.sizeof.&The sizeof operator returns the size of a variable in bytes. For example, sizeof(a), where âaâ is integer, and will return 4.\\
\verb.?X:Y.&If Condition is true then it returns value of X otherwise returns value of Y.\\
\verb.,.&The comma operator causes a sequence of operations to be performed. The value of the entire comma expression is the value of the last expression of the comma-separated list.\\
\verb+.+&The member operator \verb,., accesses a member of the operand on the left as specified by the operator on the right.\\
\verb.->.&The member operator \verb.->. is used to dereference the operand on the left and access one of its members indicated by the operand on the right.\\
Casts&Casting operators convert one data type to another. For example \verb.int(2,200). would return \verb.2..\\
\verb.&.&The address operator returns the address of a variable.\\
\verb.*.&The dereference operator returns the value the operand points to.\\
\end{TTable}

\subsection{Operator Precedence and Associativity}

\begin{TTable*}{|c|lp{0.5\linewidth}|l|}{\small}
P.&Operator&Description&Associativity\\\hline
1&\verb+::+&Scope resolution&\multirow{6}{*}{Left-to-right}\\\cline{1-3}
\multirow{5}{*}{2}&\verb.a++ a--.&Suffix/postfix increment and decrement&\\
&\verb.type() type{}.&Functional cast&\\
&\verb.a().&Function call&\\
&\verb.a[].&Subscript&\\
&\verb+. ->+&Member access&\\\hline
\multirow{9}{*}{3}&\verb.++a --a.&Prefix increment and decrement&\multirow{9}{*}{Right-to-left}\\
&\verb.+a -a.&Unary plus and minus&\\
&\verb.! ~.&Locigal NOT and bitwise NOT&\\
&\verb.(type).&C-style cast&\\
&\verb.*a.&Dereference&\\
&\verb.&a.&Adress-of&\\
&\verb.sizeof.&Size-of&\\
&\verb.new new[].&Dynamic memory allocation&\\
&\verb.delete delete[].&Dynamic memory deallocation&\\\hline
4&\verb+.* ->*+&Pointer-to-member&\multirow{11}{*}{Left-to-right}\\
5&\verb+a*b a/b a%b+&Multiplication, division, remainder&\\\cline{1-3}
6&\verb.a+b a-b.&Addition and subtraction&\\\cline{1-3}
7&\verb.<< >>.&Bitwise left shift and right shift&\\\cline{1-3}
8&\verb.<=>.&Three-way comparison operator&\\\cline{1-3}
9&\verb.< <= > >=.&Relational operators&\\\cline{1-3}
10&\verb.== !=.&Relational operators&\\\cline{1-3}
11&\verb.&.&Bitwise AND&\\\cline{1-3}
12&\verb.^.&Bitwise XOR&\\\cline{1-3}
13&\verb.|.&Bitwise OR&\\\cline{1-3}
14&\verb.&&.&Logical AND&\\\cline{1-3}
15&\verb.||.&Logical OR&\\\hline
\multirow{7}{*}{16}&\verb.a?b:c.&Ternary conditional&\multirow{7}{*}{Right-to-left}\\
&\verb.throw.&throw operator&\\
&\verb.=.&Direct assignment&\\
&\verb.+= -=.&\multirow{4}{*}{Compound assignments}&\\
&\verb.*= /= %=.&&\\
&\verb.<<= >>=.&&\\
&\verb.&= ^= |=.&&\\\hline
17&\verb.,.&Comma&Left-to-right\\
\end{TTable*}

\ifnum\conditionmacro=1
\subsubsection{How to use this table}

\begin{TPCpp}
cout<<a&&b;    //(cout<<a)&&b;

*p++           //*(p++);

a = b = c = d; //a = (b =(c = d)));

a + b - c;     //(a + b) - c;

delete ++*p;   //delete(++(*p))
\end{TPCpp}

\begin{enumerate}
\item By its precedence \verb+<<+ is evaluated before \verb+&&+.
\item By its precedence \verb.++. is evaluated before \verb.*..
\item Operators with the same precedence are evaluated based on their associativity. For right-to-left associative operators as \verb+=+, the evaluation proceeds from right to left.

Thus the assignments made in line 5 are in the order of their execution: \verb+c = d;+ which returns a reference to \verb+c+, \verb+b = c;+ which returns a reference to \verb+b+ and \verb+a = b;+.
\item Operators with the same precedence are evaluated based on their associativity. For left-to-right associative operators as \verb-+- and \verb+-+ the evaluation proceeds from left to right.
\item \verb.++()., \verb.*(). and \verb+delete+ have the same precedence, and are thus evaluated based on their associativity, which is right-to-left. Therefore \verb.++(). is evaluated after \verb.*(). and \verb+delete+ is evaluated last.
\end{enumerate}

If written badly expression can result in undefined behaviour:

\begin{TPCpp}
f(++i, ++i);
n = ++i + i;
b = ++a - a++;
\end{TPCpp}
\fi

\textbf{Avoid changing variables which are used again in the same expression.}

\section{Loop Types}

\subsection{while}

\subsection{for}

\subsection{do...while}

\subsection{Loop Control Statements}
%break continue goto

\section{Conditional Statements}

\subsection{if}

\subsection{if...else}

\subsection{switch}

\subsection{? : Operator}

\section{Functions}

\subsection{Structure}

\subsection{Declaration and Definition}

\subsection{Calling a function}

\subsection{Function Arguments}

\subsubsection{Call by Value}

\subsubsection{Call by Reference}
%and by pointer - both in same category?

\subsubsection{Default Values for Parameters}

\subsection{Recursion}

\subsection{Inline Functions}

\section{Arrays}

\section{vector}

\section{Strings}

\subsection{C-Style Character String}

\subsection{string}

\section{Pointers}

\section{References}

\section{Input/Output}

\section{struct}

\section{class}

\subsection{Class Members}

\subsection{Class Access Modifiers}

\subsection{Constructor and Destructor}

\subsection{Copy Constructor}

\subsection{friend}

\subsection{this}

\subsection{Static Members}

\section{Inheritance}

\subsection{Access Control and Inheritance}

\section{Overloading}

\subsection{Function overloading}

\subsection{Operator overloading}

\subsubsection{Overloadable operators}

\section{Polymorphism}

\section{Dynamic Memory}

\section{Namespaces}

\section{Templates}

\section{Preprocessor}

\section{Signal Handling}

\section{Standard Template Library}

\section{Libraries}

\subsection{iostream}

\subsection{math}

\subsection{ctime}







\end{multicols*}
\end{document}
