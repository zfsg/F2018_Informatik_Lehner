\documentclass[10pt,a4paper]{scrartcl}

\usepackage[english]{babel}
\usepackage{glossaries}\usepackage[xindy]{imakeidx}

%Set to 0 for making without examples
%Set to 1 for making with examples
\gdef\conditionmacro{1}

%\newenvironment{example}{
%\ifnum\conditionmacro=1}
%{\fi}

\input{../Headerfiles/Packages}
\input{../Headerfiles/Titles}
\input{../Headerfiles/Commands}
\input{../Headerfiles/ENVIRONMENTS}
\graphicspath{{Pictures/}}
\parindent 0pt

\title{Informatics}
\author{GianAndrea Müller}

\newtheorem{define}{Definition}

\makenoidxglossaries
\newglossaryentry{Algorithm}{name={Algorithm},description={An algorithm is a set of rules that defines a sequence of operations to get to the solution of a problem.}}
\newglossaryentry{Language}{name={Language},description={A programming language is a set of instructions for a computer that can be used to write programs that implement algorithms.}}
\newglossaryentry{Syntax}{name={Syntax},description={The syntax of a computer language is the set of rules that defines the combinations of symbols that are considered to be a correctly structured document or fragment in that language. Is a program grammatically correct?}}
\newglossaryentry{Semantics}{name={Semantics},description={The semantics of a computer language define how the language has to be interpreted. What is the meaning of a certain program?}}
\newglossaryentry{Editor}{name={Editor},description={A program that allows writing code. There exist powerful editors that can check syntactical correctness on the fly.}}
\newglossaryentry{Compiler}{name={Compiler},description={A compiler translates a program written in a programming language to machine code, such that it can be executed by the machine.}}
\newglossaryentry{Computer}{name={Computer},description={A computer is a device that is capable of executing machine code.}}
\newglossaryentry{Comments}{name={Comments},description={Comments document the implemented algorithm within the program for the reader. They are ignored by the compiler.}}
\newglossaryentry{IncDir}{name={Include Directives},description={Include directives specify the additional libraries used in a program.}}
\newglossaryentry{Main}{name={The main function},description={The main function exists in every cpp-program. It is unique and contains the all instructions necessary to execute the program.}}
\newglossaryentry{Statement}{name={Statement},description={Statements are the building blocks of a program. They are executed sequentially and end with a semicolon.}}
\newglossaryentry{Declaration}{name={Declaration},description={A declaration introduces a new name to the program.}}
\newglossaryentry{Definition}{name={Definition},description={A definition introduces a body to a name within the program.}}
\newglossaryentry{Initialization}{name={Initialization},description={An initialization introduces a value to a defined name and body.}}
\newglossaryentry{Literals}{name={Literals},description={Literals represent constant value within the program. They have a defined type and value.}}
\newglossaryentry{Variables}{name={Variables},description={Variables represent possibly changing values within the program. They have name, type, value and address.}}
\newglossaryentry{Objects}{name={Objects},description={Objects represent values in the computer memory. They have type, adress and value. They can be named, but can also be anonymous. Described less generally an object can be a variable, a data structure, a function, or a method.}}
\newglossaryentry{Expressions}{name={Expressions},description={Expressions represent calculations. They are a combination of values, literals, operators and functions. They are primary if they consist of a single name/literal. Otherwise they are compound. They have type and value.}}
\newglossaryentry{Lvalue}{name={Lvalue},description={An lvalue is a changeable expression that has an address.}}
\newglossaryentry{Rvalue}{name={Rvalue},description={An rvalue is an expression that is not an lvalue. An rvalue cannot be changed. Every lvalue can be used as an rvalue but not vice-versa.}}
\newglossaryentry{Operator}{name={Operator},description={An operator connects expressions to compound expressions. It specifies the expected operand in type and if it is an rvalue or an lvalue. Operators have an arity.}}
\newglossaryentry{Arity}{name={Arity},description={Arity is the number of arguments or operands an operator or a function takes. For example there exist unary and binary operators.}}
\newglossaryentry{Block}{name={Block},description={A block in c++ is a number of lines of code enclosed by curly brackets.}}

\begin{document}
\begin{multicols*}{4}
\maketitle
\tableofcontents
\end{multicols*}

\begin{multicols*}{2}

%Nice to know
\newcommand{\ntn}[1]{\textcolor{blue}{#1}}

\ifnum\conditionmacro=1
\section{How to...}

\subsection{\ntn{... use this summary}}

This summary is an overview of the functionality of \verb.C++. in connection with the informatics course for mechanical engineers. It covers the content of the lectures but also contains additional information.

To emphasize the connection to the lecture all chapters containing purely additional information are marked in blue.

\subsection{\ntn{... correct compilation errors}}

Read error messages, review basic syntax, look for the additional semicolon.

\subsection{\ntn{... correct runtime errors}}

Use a \easyurl{debugger}{https://www.visualstudio.com/de/thank-you-downloading-visual-studio/?sku=Community&rel=15}.

Or include safeguards in your code, checking the state of variables during runtime:

\begin{TPCpp}
//#define NDEBUG  //uncomment to ignore assertions
#include <cassert>

int main(){
	cout<<"Enter 0 or 1"<<endl;
	int a;
	cin>>a;
	assert( a == 1 || a == 0 );
}
\end{TPCpp}

\subsection{... approach problems}

\begin{enumerate}
\item Define your problem.
\item Find your algorithm.
\item Code feature.
\item Compile.
\item \verb+goto+ 3.
\end{enumerate}

\subsection{... find more information}

\begin{itemize}
\item \easyurl{Comprehensive Tutorial}{https://www.tutorialspoint.com/cplusplus/index.htm}
\item \easyurl{User friendly documentation}{http://www.cplusplus.com}
\item \easyurl{Extensive technical documentation}{http://en.cppreference.com/w/}
\end{itemize}
\fi

%Add all entries to glossary even though unused
\glsaddall

\printnoidxglossary[sort=def,title={Terms},nonumberlist=true,nopostdot=true]

\section{\ntn{Nice to know}}

\subsection{\ntn{Preprocessor directives}}

Preprocessor directives are lines preceded by a \verb+#+. These lines are not program statements but directives for the preprocessor, thus are evaluated before the program is compiled.
These preprocessor directives extend only across a single line of code. As soon as a newline character is found, the preprocessor directive is ends. No semicolon (;) is expected at the end of a preprocessor directive. The only way a preprocessor directive can extend through more than one line is by preceding the newline character at the end of the line by a backslash (\textbackslash).

\subsubsection{\ntn{Macro Definitions}}

\begin{TPCpp}
#define identifier replacement
\end{TPCpp}

When the preprocessor encounters this directive it replaces any occurrence of \verb+identifier+ in the rest of the code by \verb+replacement+. A macro lasts until it is undefined with \verb+#undef+. As seen in the following example it is also possible to define functions:

\begin{TPCpp}
//A simple constant
#define TABLE_SIZE 100
int table1 [TABLE_SIZE];
#undef TABLE_SIZE //lasts until here

//A function
#define getmax(a,b) a>b?a:b

int main(){
	int x = 5, y;
	y = getmax(x,2); //replaced as: y = x>2?x:2
}

}
\end{TPCpp}

This would replace any occurrence of \verb+getmax+ followed by two arguments by the replacement expression, but also replace each identifier by its respective argument.

\begin{TPCpp}
#define str(x) #x

cout<<str(test); // replaced as: cout<<"test";
\end{TPCpp}

As seen above an identifier preceded by \verb+#+ will be replaced by the argument in double quotes.

\begin{TPCpp}
#define glue(a,b) a ## b
glue(c,out) << "test"; //replaced as: cout << "test";
\end{TPCpp}

The operator \verb+##+ concatenates two arguments leaving no white space between them.

\subsubsection{\ntn{Conditional inclusions}}

The directives \verb+#ifdef+, \verb+#ifndef+, \verb+#if+, \verb+#endif+, \verb+#else+ and \verb+#elif+ allow to include or discard part of the code if a certain condition is met.

\verb+#ifdef+ allows a section of a program to be compiled only if the macro that is specified as the parameter has been defined, no matter which its value is. \verb+#endif+ ends the conditional block.

\begin{TPCpp}
#ifdef TABLE_SIZE
int table[TABLE_SIZE];
#endif
\end{TPCpp}

\verb+#ifndef+ serves for the exact opposite: the code between \verb+#ifndef+ and \verb+#endif+ directives is only compiled if the specified identifier has not been defined yet.

\begin{TPCpp}
#ifndef TABLE_SIZE
#define TABLE_SIZE 100
#endif
int table[TABLE_SIZE];
\end{TPCpp}

The \verb+#if+, \verb+#else+ and \verb+#elif+ directives serve to specify some condition to be met in order for the portion of code they surround to be compiled. The condition that follows \verb+#if+ and \verb+#elif+ can only evaluate constant expressions, including macro expressions.

\begin{TPCpp}
#if TABLE_SIZE>200
#undef TABLE_SIZE
#define TABLE_SIZE 200

#elif TABLE_SIZE<50
#undef TABLE_SIZE
#define TABLE_SIZE 50

#else
#undef TABLE_SIZE
#define TABLE_SIZE 100
#endif

int table[TABLE_SIZE];
\end{TPCpp}

Notice that the compelling advantage of preprocessor directives over normal conditional statements is that preprocessor directives are evaluated before the code is compiled. An interesting application of that concept is the making of different versions of a program, for instance one version that has special debugging precautions and a second version which runs faster but omits these safety measures.

\subsubsection{\ntn{Line control}}

 When we compile a program and some error happens during the compiling process, the compiler shows an error message with references to the name of the file where the error happened and a line number, so it is easier to find the code generating the error.

The \verb+#line+ directive allows us to control both things, the line numbers within the code files as well as the file name that we want that appears when an error takes place.

\begin{TPCpp}
//#line number "filename"

#line 20 "assigning variable"
int a?;
\end{TPCpp}

This code will generate an error that will be shown as error in file \verb+"assigning variable", line 20+.

\subsubsection{\ntn{Error directive}}

The \verb+#error+ directive aborts the compilation process when it is found, generating a compilation error that can be specified as its parameter.

\begin{TPCpp}
#ifndef _cplusplus
#error A C++ compiler is required!
#endif
\end{TPCpp}

\subsubsection{\ntn{Source file inclusion}}

The \verb+#include+ directive is replace by the entire content of the specified header or file. There are two ways to use \verb+#include+:

\begin{TPCpp}
#include <header>
#include "file"
\end{TPCpp}

In the first case, a header is specified between angle-brackets $<>$. This is used to include headers provided by the implementation, such as the headers that compose the standard library (iostream, string,...). Whether the headers are actually files or exist in some other form is implementation-defined, but in any case they shall be properly included with this directive.

The syntax used in the second \verb+#include+ uses quotes, and includes a file. The file is searched for in an implementation-defined manner, which generally includes the current path. In the case that the file is not found, the compiler interprets the directive as a header inclusion, just as if the quotes (``'') were replaced by angle-brackets ($<>$).

\subsubsection{\ntn{Pragma directive}}

This directive is used to specify diverse options to the compiler. These options are specific for the platform and the compiler you use. Consult the manual or the reference of your compiler for more information on the possible parameters that you can define with \verb+#pragma+.

\subsubsection{\ntn{Predefined macro names}}

\begin{TTable}[1]{lp{0.7\linewidth}}
\verb+__LINE__+&	Integer value representing the current line in the source code file being compiled.\\
\verb+__FILE__+&	A string literal containing the presumed name of the source file being compiled.\\
\verb+__DATE__+&A string literal in the form ``Mmm dd yyyy'' containing the date in which the compilation process began.\\
\verb+__TIME__+&A string literal in the form ``hh:mm:ss'' containing the time at which the compilation process began.\\
\verb+__cplusplus+&An integer value. All C++ compilers have this constant defined to some value. Its value depends on the version of the standard supported by the compiler.\\
\end{TTable}

\section{Positional Notation}

In short, a positional notation is defined as a method of representing or encoding numbers. It is characterized by its use of the same symbol for different orders of magnitude (for example the ``ones place'', the ``tens place'' and the ``hundreds place'' in case of the decimal system). With the inclusion of the radix point, a symbol separating the integer part of the number of the fractional part, positional notation can represent rational numbers.

\subsection{Binary numbers}

A binary number is a number expressed by a base-2 numeral system which uses only two symbols, typically 0 and 1.

\subsubsection{From Decimal to Binary}

To find the binary representation of a decimal number repeatedly divide by two and list the remainders. The resulting sequence is the binary representation in reverse order. For comparison the same algorithm is applied to a decimal number on the left.

\begin{minipage}{0.45\linewidth}
\begin{align*}
91310&=10*9131+&0\\
9131&=10*913+&1\\
913&=10*91+&3\\
91&=10*9+&1\\
9&=10*0+&9
\end{align*}
\end{minipage}
\hfill
\begin{minipage}{0.45\linewidth}
\begin{align*}
61&=2*30+&1\\
30&=2*15+&0\\
15&=2*7+&1\\
7&=2*3+&1\\
3&=2*1+&1\\
1&=2*0+&1
\end{align*}
\end{minipage}

\subsubsection{From Binary to Decimal}

To find the decimal representation of a binary number simply list its digits, multiply each with its place value and sum up.

\begin{tabular}{llllllll}
&&&&&&&$\sum$\\
Ziffern&1&1&1&1&0&1\\
Multiplikator&32&16&8&4&2&1\\
Wert&32&16&8&4&0&1&61\\
\end{tabular}

\subsubsection{Two's complement}

Two ways of interpreting signed numbers are shortly compared here in order to motivate the convention used.

\begin{TTable}{lll|lll}
\multicolumn{6}{c}{\textbf{Sign and magnitude}}\\
Bits&Unsigned value&S \& M&Bits&Unsigned value&S \& M\\
0000&0&0&1000&8&-0\\
0001&1&1&1001&9&-1\\
0010&2&2&1010&10&-2\\
0011&3&3&1011&11&-3\\
0100&4&4&1100&12&-4\\
0101&5&5&1101&13&-5\\
0110&6&6&1110&14&-6\\
0111&7&7&1111&15&-7\\
\end{TTable}

The interpretation with sign and magnitude interprets the first bit as the sign bit. This results in a range of $-(2^{N-1}-1)$ to $2^{N-1}-1$, where N is the number of available bits.

\begin{TTable}{lll|lll}
\multicolumn{6}{c}{\textbf{Two's complement}}\\
Bits&Unsigned value&2's&Bits&Unsigned value&2's\\
0000&0&0&1000&8&-8\\
0001&1&1&1001&9&-7\\
0010&2&2&1010&10&-6\\
0011&3&3&1011&11&-5\\
0100&4&4&1100&12&-4\\
0101&5&5&1101&13&-3\\
0110&6&6&1110&14&-2\\
0111&7&7&1111&15&-1\\
\end{TTable}

The two's complement interprets the first bit as the negative of its value in an unsigned interpretation. As seen above this allows omitting $-0$ as an encoded value and thus enlarges the range by one number: $-(2^{N-1})$ to $2^{N-1}-1$.

\subsubsection{Overflow and Underflow}

When calculating with numbers in a restricted range of values as on computer memory arithmetic operations can lead to over- and underflows. This is dangerous since there is no error message for such miscalculations.

\paragraph{unsigned int}

When an unsigned int is assigned a negative value (underflow) the resulting value can be described as follows:

\mportant{$\mathbf{unsigned\ int}\ u \leftarrow x = \begin{cases} x \geq 0 & x \\ x < 0 & x + 2^B\end{cases}$}

Where $2^B$ is twice the value of the most significant bit and $B$ is the number of bits. When the assigned value is in two's complement (which it is for c++) the representation does not have to be changed internally. Instead the unsigned interpretation effects the addition of $2^B$ since now the first bit of the number is not given a negative but a positive value. Note that the only case this does not happen is if the first bit is zero, which means that the assigned number was non-negative in the first place!

\paragraph{int}

When an int is assigned a value larger than can be saved a so called overflow happens, which means that the first bit of the number is switched and a large negative number results.

\subsubsection{Estimation of the order of magnitude}

\begin{align*}
2^{10}&=1024=1Ki\approx 10^3\\
2^{32}&=3\cdot(1024)^3= 4Gi\\
2^{64}&=16Ei\approx 16\cdot10^{18}
\end{align*}

\subsubsection{\ntn{Orders of magnitude of data}}

\begin{TTable}{lll|lll}
\multicolumn{6}{c}{Multiple of bytes}\\
\multicolumn{3}{c}{Decimal}&\multicolumn{3}{c}{Binary}\\
Value&&Metric&Value&&IEC\\
$1000$&kB&kilobyte&$1024$&KiB&kibibyte\\
$1000^2$&MB&megabyte&$1024^2$&MiB&mebibyte\\
$1000^3$&GB&gigabyte&$1024^3$&GiB&gibibyte\\
$1000^4$&TB&terabyte&$1024^4$&TiB&tebibyte\\
$1000^5$&PB&petabyte&$1024^5$&PiB&pebibyte\\
$1000^6$&EB&exabyte&$1024^5$&EiB&exbibyte\\
\end{TTable}

\subsection{Floating point numbers}

A possible representation of numbers with a fractional part is fixing the number of digits before and after the radix point. The disadvantage of such a representation lies in its limitedness. A floating point system can tremendously increase the flexibility of such a notation. It consists of a certain number of significant digits and  the position of the radix point. In other words it has a mantissa and an exponent. Note that no floating point system can fully represent $\mathbb{R}$, since the length of the mantissa is limited.

\subsubsection{Description}

Any floating point system can be described with a small set of parameters:

\[\mathcal{F}^{(\ast)}(\underbrace{\beta}_\text{Basis $\geq$ 2},\overbrace{p}^\text{Length of mantissa$\geq$1},\underbrace{e_{min},e_{max}}_\text{smallest and largest exponent})\]

Where the asterisk, when present, signalises that the represented number always start with a 1 (only works for basis 2). This first digit is called the hidden bit, since based on the above assumption, it does not need to be saved explicitly. Nevertheless it is counted as part of the mantissa. Of course this definition

When saved in computer memory the available bits are assigned in the following manner. Example for $\mathcal{F}^\ast(2,6,-7,7)$.

\begin{Large}
\[{\color{red}{0}}{\color{green}{0000}}{\color{blue}{00000}}\]
\end{Large}
\begin{itemize}
\item\textcolor{red}{Sign bit}
\item\textcolor{blue}{Mantissa bits}
\item\textcolor{green}{Exponent bits}
\end{itemize}

\begin{enumerate}
\item All number are in normalized representation, which means that the exponent is chosen such, that there is a single 1 on the left side of the radix point.
\item The exponent is read as an unsigned int with a bias, for this example we shift the value range by 8, such that $0000\hat{=} -8$.
\item For making certain numbers available that are otherwise not representable the smallest exponent $0000$ is given up for encoding certain special values as shown below:

\begin{center}
$\underbrace{\textcolor{red}{0}\textcolor{green}{0000}\textcolor{blue}{00000}}_\text{Null}\qquad \underbrace{\textcolor{red}{0}\textcolor{green}{0000}\textcolor{blue}{00001}}_{+\infty}\qquad\underbrace{\textcolor{red}{0}\textcolor{green}{0000}\textcolor{blue}{00010}}_{-\infty}\qquad\underbrace{\textcolor{red}{0}\textcolor{green}{0000}\textcolor{blue}{00011}}_\text{NaN}$
\end{center}
\end{enumerate}

\subsubsection{Smalles normalized and largest positive number}

\[2^{e_{min}}\qquad\qquad\qquad\left(1-\left(\frac{1}{2}\right)^p\right)\beta^{e_{max}+1}\]

\subsubsection{Decimal to binary representation}

\begin{minipage}{0.45\linewidth}
\begin{center}
\begin{tabular}{l|l|l}
$x$&$d_i$&$x-d_i$\\\hline
1.934&1&0.934\\
9.34&9&0.34\\
3.4&3&0.4\\
4&4&0
\end{tabular}
\end{center}
\end{minipage}
\hfill
\begin{minipage}{0.45\linewidth}
\begin{center}

\begin{tabular}{r|l|l}
$x$&$b_i$&$x-b_i$\\\hline
1.9&1&0.9\\
1.8&1&0.8\\
\textbf{1.6}&1&0.6\\
1.2&1&0.2\\
0.4&0&0.8\\
\textbf{1.6}&1&0.6\\
&$\vdots$&
\end{tabular}
\end{center}
\begin{equation*}
1.1\overline{1100}
\end{equation*}
\end{minipage}

\subsubsection{Binary to decimal representation}

\begin{center}
\begin{tabular}{ll|l|l|l|l|l|l|l}
binary:&1&1&1&1&.&1&1&1\\\hline
decimal:&8&4&2&1&&$\frac{1}{2}$&$\frac{1}{4}$&$\frac{1}{8}$
\end{tabular}
\end{center}

\subsubsection{Guidelines when using floating point arithmetics}

\begin{enumerate}
\item Single precision: $\mathcal{F}^\ast(2,24,-126,127)$
\item Double precision: $\mathcal{F}^\ast(2,53,-1022,1023)$
\item Never test rounded floating point numbers for equality!
\item Never add two floating point numbers of very different magnitude!
\item Never subtract two numbers of comparable size!
\end{enumerate}

\subsection{Hexadecimal numbers}

A hexadecimal number is a number expressed by a base-16 numeral system which uses the symbols 0-9 and A-F. For conversion between hexadecimal and decimal apply the algorithms learned for binary numbers. On preference convert to binary first, using hex nibbles.

\subsubsection{Hex nibbles}

Any of the hexadecimal digits can be understood as a nibble (4 bits). Therefore hexadecimal numbers can be viewed as a compact representation of binary numbers, since every hexadecimal bit directly translates to a certain nibble as listed below.

\begin{TTable}{lll|lll}
hex&bin&dec&hex&bin&dec\\
0&0000&0&8&1000&8\\
1&0001&1&9&1001&9\\
2&0010&2&A&1010&10\\
3&0011&3&B&1011&11\\
4&0100&4&C&1100&12\\
5&0101&5&D&1101&13\\
6&0110&6&E&1110&14\\
7&0111&7&F&1111&15\\
\end{TTable}

\ifnum\conditionmacro=1
Beispiel mit 32-bit Zahlen: 0x00000000 -- 0xffffffff
\begin{itemize}
\item 0x80000000: höchstes Bit einer 32-bit Zahl gesetzt
\item 0xffffffff: alle Bits einer 32-bit Zahl gesetzt
\end{itemize}
\fi

\section{Extended Backus-Naur-Form}

The Extended Backus-Naur-Form (EBNF) is a formal metalanguage used to describe context free grammars.

\begin{itemize}
\item \textbf{metalanguage:} A language about language.
\item \textbf{context free grammar:} Rules for composing the words of a language that do not depend on the context. 
\end{itemize}

\textbf{Short and simple:} The EBNF is a language that defines with a simple syntax what sentences can be built with the words of another language. The EBNF consists of three main elements:

\begin{enumerate}
\item \textbf{Terminals:} Symbols that are the elemental basis of the language and cannot be further replaced.
\item \textbf{Nonterminals:} Symbols that can be replaced by other symbols based on certain rules.
\item \textbf{Derivation rules:} Rules that define which nonterminals are to be replaced by which terminals and in what manner.
\end{enumerate}

The syntax for EBNF can be summed up as follows:

\begin{TTable}{ll@{$\qquad$}ll}
Usage&Notation&Usage&Notation\\
definition&\verb+=+&grouping&\verb+( ... )+\\
concatentation&\verb.,.&terminal string&\verb," ... ",\\
termination&\verb+;+&terminal string&\verb+' ... '+\\
alternation&\verb+|+&comment&\verb+(* ... *)+\\
optional&\verb+[ ... ]+&special sequence&\verb+? ... ?+\\
repetition&\verb+{ ... }+&exception&\verb+-+\\
\end{TTable}

As an example we have here an EBNF defining whole numbers:

\begin{TPCpp}
digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
digit                = "0" | digit excluding zero ;
natural number = digit excluding zero, {digit};
whole number = "0" | [ "-" ], natural number;
\end{TPCpp}

A natural application of the EBNF is the definition of programming languages. The use of recursive functions then allows direct implementation of the defined derivation rules resulting in a parser. A parser is a program that checks whether a stream of symbols adheres to a certain grammar.

\section{Syntax}

\subsection{Basic program}

\begin{TPCpp}
#include <iostream>
//#include "local_header_file.h"

/*
 * Function declarations (and definitions)
 */

int main(int argc, char ** argv)
{
	  /*
	   * Function calls
	   */
    std::cout << "Hello World!" << std::endl;
    return 0;
}

/*
 * Function definitions
 */
\end{TPCpp}

\subsection{Identifiers}

A valid identifier, i.e. the name of a variable is:

\begin{itemize}
\item an arbitrarily long sequence of digits, underscores, lowercase and uppercase Latin letters.
\item not starting with a digit.
\item not starting with two or more underscores.
\item not starting with an underscore followed by a capital letter.
\item not a \easyurl{keyword}{http://en.cppreference.com/w/cpp/keyword} of cpp.
\end{itemize}

\ifnum\conditionmacro=1
More information on \easyurl{Identifiers}{http://en.cppreference.com/w/cpp/language/identifiers}.
\fi

\subsection{Comments}

C++ allows masking code such that it is not interpreted as part of the program. This enables documenting the program. There are different possibilities:

\begin{TPCpp}
// normal comment

/*
multi
line
comment
*/
\end{TPCpp}

Both versions can be nested:

\begin{TPCpp}
///*comment in a comment*/

/*
cout<<"Hello World!<<endl; //comment in a comment
*/
\end{TPCpp}

\subsection{Data Types}

\subsubsection{Primitive Types}

\ifnum\conditionmacro=1
\begin{TTable}[1]
{ll}
Type&Keyword\\\midrule
Boolean&bool\\
Character&char\\
Integer&int\\
Floating point&float\\
Double floating point&double\\
Valueless&void\\
\end{TTable}
\fi

\paragraph{char}

%TODO add ascii code and explanation of mapping

\subsubsection{Type modifiers}

\ifnum\conditionmacro=1
There exist a number of type modifiers:

\begin{TTable}[1]
{ll}
Modifier&Effect\\\midrule
signed&variable interpreted as signed\\
unsigned&variable interpreted as unsigned\\
short&half number of allocated bits if possible\\
long&double number of allocated bits if possible\\
\end{TTable}

Based on the primitive types and their modifiers the spectrum of available types can be established. Their sizes differ depending on compiler and environment.
\fi

\begin{TTable}[1]
{llc}
Modifier&Typical Bit Width&Typical Range\\\midrule
char&1byte&-127 to 127\\
unsigned char&1byte&0 to 255\\
signed char&1byte&-127 to 127\\
int&4byte&-2'147'483'648 to 2'147'483'647\\
unsigned int&4bytes&0 to 4'294'967'295\\
signed int&4bytes&-2'147'483'648 to 2'147'483'647\\
short int&2bytes&-32'768 to 32'767\\
unsigned short int&2bytes&0 to 65'535\\
signed short int&2bytes&-32'768 to 32'767\\
long int&4bytes&-2'147'483'648 to 2'147'483'647\\
signed long int&4bytes&-2'147'483'648 to 2'147'483'647\\
unsigned long int&4bytes&0 to 4'294'967'295\\
float&4bytes&+/- 3.4e +/- 38 (~7 digits)\\
double&8bytes&+/- 1.7e +/- 308 (~15 digits)\\
long double&8bytes&+/- 1.7e +/- 308 (~15 digits)\\
\end{TTable}

\ifnum\conditionmacro=1
\subsubsection{\ntn{Find type sizes on your system}}
\begin{TPCpp}
#include <iostream>
using namespace std;

int main() {
   cout<< "Size: char : "<<sizeof(char)<<endl;
   cout<< "Size: int : "<<sizeof(int)<<endl;
   cout<< "Size: short int : "<<sizeof(short int)<<endl;
   cout<< "Size: long int : "<<sizeof(long int)<<endl;
   cout<< "Size: float : "<<sizeof(float)<<endl;
   cout<< "Size: double : "<<sizeof(double)<<endl;
   
   return 0;
}
\end{TPCpp}
\fi

\subsubsection{Find minimum and maximum value of int}

\begin{TPCpp}
#include <iostream>
#include <limits>
using namespace std;

int main() {
   cout << "Minimum int value is "
        << numeric_limits<int>::min() << ".\n"
        << "Maximum int value is "
        << numeric_limits<int>::max() << ".\n";
   return 0;
}
\end{TPCpp}

\subsubsection{Type qualifiers: const \ntn{volatile restrict}}
%const volatile restrict


\paragraph{const} Objects of type \verb+const+ cannot be changed by the program during execution.

\textbf{const-correctness: Any variable that does not change its value during the course of the program is to be declared as const!}
\paragraph{\ntn{volatile}} The modifier \verb+volatile+ tells the compile that a variable's value may be changed in ways not explicitly specified by the program. (Imagine for instance manually changing the position of a switch on a microprocessor.)
\paragraph{\ntn{restrict}} A pointer qualified by \verb+restrict+ is initially the only means by which the object it points to can be accessed.

\subsubsection{\ntn{Storage classes}}
%auto register static extern mutable

A storage class defines the scope (visibility) and life-time of variables and/or functions within a C++ Program. These specifiers precede the type that they modify.

\paragraph{\ntn{auto}}

The auto storage class is the default storage class for all local variables.

\paragraph{\ntn{register}}

The register storage class is used to define local variables that should be stored in a register instead of RAM. This means that the variable has a maximum size equal to the register size (usually one word) and can't have the unary '\&' operator applied to it (as it does not have a memory location).

The register should only be used for variables that require quick access such as counters. It should also be noted that defining 'register' does not mean that the variable will be stored in a register. It means that it MIGHT be stored in a register depending on hardware and implementation restrictions.

\paragraph{\ntn{static}}

The static storage class instructs the compiler to keep a local variable in existence during the life-time of the program instead of creating and destroying it each time it comes into and goes out of scope. Therefore, making local variables static allows them to maintain their values between function calls.

The static modifier may also be applied to global variables. When this is done, it causes that variable's scope to be restricted to the file in which it is declared.

In C++, when static is used on a class data member, it causes only one copy of that member to be shared by all objects of its class.

\paragraph{\ntn{extern}}

The extern storage class is used to give a reference of a global variable that is visible to ALL the program files. When you use 'extern' the variable cannot be initialized as all it does is point the variable name at a storage location that has been previously defined.

When you have multiple files and you define a global variable or function, which will be used in other files also, then extern will be used in another file to give reference of defined variable or function. Just for understanding extern is used to declare a global variable or function in another file.

The extern modifier is most commonly used when there are two or more files sharing the same global variables or functions as explained below.

\paragraph{\ntn{mutable}}

The mutable storage class only applies to non-static class members of non-reference and non-const type. When a class member is declared mutable it can be changed by const member functions.

\subsubsection{Variable Definition}

A variable definition tells the compiler where and how much storage to create for the variable. A variable definition specifies a data type and name. Type has to be either a primitive type or a user defined object. Multiple names can be introduced at once if separated by commas.

\begin{TPCpp}
int i,j,k;
\end{TPCpp}

This line both declares and defines the variables i,j and k.
Direct initialization is also possible:

\begin{TPCpp}
int d = 3, f = 2;
\end{TPCpp}

\textbf{If a variable is left uninitialized its value is undefined in general}. However, variables with static storage duration are implicitly set to 0.

\subsubsection{\ntn{Variable Declaration}}

It is possible to declare a variable without defining it. The declaration is accepted during compilation but has to be fitted with a definition at the time of linking of the program. This means that if a program consists of multiple files you can declare your variable wherever you need it but only define it once, since multiple definitions of the same variable are prohibited.

\begin{TPCpp}
//Variable declaration
extern int a,b; //Compiler knows that the variable exists

//Variable definition
int a,b; //Compiler knows that the variable exists
         //And allocates the storage space needed
\end{TPCpp}

\subsubsection{\ntn{typedef} and using}

You can create a new name for an existing type with \verb+using+ or \verb+typedef+:

\begin{TPCpp}
//typedef type newname;

typedef unsigned int uint;

//using newname = type;

using uchar = unsigned char;

uint a = 3; //a is an unsigned int

uchar b = '2'; //b is an unsigned char
\end{TPCpp}

\subsubsection{\ntn{union}}

A union is a special class type that can hold only one of its non-static data members at a time. The union is only as big as necessary to hold its largest data member. The other data members are allocated in the same bytes as part of that largest member. The details of that allocation are implementation-defined, and it's undefined behavior to read from the member of the union that wasn't most recently written.

\subsubsection{\ntn{enum}}

An enumerated type declares an optional type name and a set of zero or more identifiers that can be used as values of the type. This can improve readability of the code as values are given meaning.

\begin{TPCpp}
//enum enum-name {list of names} var-list;

enum day {mon, tue, wed, thu, fri, sat, sun} today;
today = mon; //today == 0
today = sun; //today == 6
\end{TPCpp}

The values assigned to the names start with zero and increment by default. But you can also directly assign values:

\begin{TPCpp}
enum color {red, green = 5, blue};
color c;
c = red;    //c == 0
c = green;  //c == 5
c = blue;   //c == 6
\end{TPCpp}

\section{Variable Scope}

A scope is a region of the program within which variable definitions persist. There are three types of scopes:

\begin{enumerate}
\item Inside a function or a block (local variables)
\item In the definition of function parameters (formal parameters)
\item Outside of all functions (global parameters)
\end{enumerate}

\subsection{Blocks}

A block is a group of statements enclose by curly brackets.

\begin{TPCpp}
{statement1; statement2; ... statementN;}
\end{TPCpp}

Control statements generate blocks as well:

\begin{TPCpp}
for (int i = 0; i < 10; i++){
	cout<<i<<endl;
}
// cout<<i<<endl; //not possible i is out of scope
\end{TPCpp}

\subsection{Local Variables}

Variables that are defined within a function or a block can only be used by statements within that same function or block.

\begin{TPCpp}
for(int i = 0; i<3; i++){ //scope of the variable i
	std::cout<<i<<" ";
} //end of scope

// std::cout<<i; will result in error
\end{TPCpp}

\ifnum\conditionmacro=1

A variable can be redefined within a block. In that case the ``closer'' definition is used.

\begin{TPCpp}
int i = 5;
{
	int i = 3;
	std :: cout << i; // outputs 3
}
std :: cout << i; // outputs 5
\end{TPCpp}
\fi

\subsection{\ntn{Global Variables}}

Global variables are defined outside of all the functions, usually on top of the program. They will hold their value throughout the life-time of your program. This also mean that all functions within your program can access these variables.

\ifnum\conditionmacro=1

Including global variables the case of maximum complication, however undesired, is the following:

\begin{TPCpp}
#include <iostream>
using namespace std;

int i = 2;

void fun(){
	cout<<i;
}

int main(){
	int i = 5;
	{
		int i = 3;
		std :: cout << i;   // outputs 3
	}
	std :: cout << i;     // outputs 5
	fun();                // outputs 2
}
\end{TPCpp}
\fi

\section{Literals}

\subsection{Integer Literals}

An integer literal can be a binary, decimal, octal or hexadecimal constant. A prefix specifies the base: \verb+0b+ for binary, \verb+0+ for octal, \verb+0x+ for hexadecimal and nothing for decimal.

An integer literal can also have a suffix that is a combination of u (unsigned) and l (long).

\ifnum\conditionmacro=1
\begin{TPCpp}
212     // Decimal number
212ul   // Long unsigned decimal number
0xFeeL  // Long hexadecimal number
0b101   // Binary representation of 5
011     // Octal representation of 9
078     // Illegal: 8 is not an octal digit
\end{TPCpp}
\fi

\subsection{Floating-point Literals}

A floating point literal has an integer part, a decimal point, a fraction part and an exponent part. You can represent floating point literals either in decimal form or exponential form.

While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.

\ifnum\conditionmacro=1
\begin{TPCpp}
3.14195      // Decimal representation of pi
314195E-5L   // Exponential representation of pi
510E         // Illegal: incomplete exponent
210f         // Illegal: no decimal or exponent
.e55         // Illegal: missing integer or fraction
\end{TPCpp}
\fi

\subsection{Boolean Literals}

There are two Boolean literals and the are part of standard C++ keywords: \verb+true+ and \verb+false+.

\ifnum\conditionmacro=1
\begin{TPCpp}
bool a = true;
cout<<a; //outputs 1
a = false;
cout<<a; //outputs 0
bool = some_integer; //true for some_integer != 0
\end{TPCpp}
\fi

The conversion from integer to bool results in \verb+true+ for all nonzero values and in \verb+false+ for zero.

\subsection{Character Literals}

Character literals are enclosed in single quotes ('). A character literal can be a plain character ('x'), an escape sequence ('\verb+\t+') or a universal character ('\verb+\u02C0+').

\begin{TTable}[1]{ll@{$\qquad$}ll}
\verb+\\+&\verb+\\+ character&\verb+\f+&Form feed\\
\verb+\'+&' character&\verb+\n+&Newline\\
\verb+\"+&'' character&
\verb+\r+&Carriage return\\
\verb+\?+&? character&\verb+\t+&Horizontal tab\\
\verb+\a+&Alert or bell&\verb+\v+&Vertical tab\\
\verb+\b+&Backspace\\
\end{TTable}

\subsection{String Literals}

String literals are enclosed in double quotes. A string contains any combination of plain characters escape sequences and universal characters.

\section{Operators}

\subsection{Arithmetic Operators}

\begin{TTable}{lp{0.8\linewidth}}
\verb.+.&Adds two operands\\
\verb.-.&Subtracts the second operand from the first\\
\verb.*.&Multiplies both operands\\
\verb./.&Divides the first operand by the second\\
\verb.%.&Returns the remainder of an integer division of the two operators\\
\verb.++.&Increases an integer value by one\\
\verb.--.&Decreases an integer value by one\\
\end{TTable}

\begin{itemize}
\item Note that the \verb+/+ operator returns a value of the same type as its operators. Thus a division of two integers, known as \textbf{integer division}, returns the rounded result of the division. 
\end{itemize}

\subsubsection{Div-Mod identity}

\begin{center}
\verb.a/b * b + a%b == a.
\end{center}

\subsubsection{Pre- and post-in-/decrement}

%TODO add content

\subsection{Relational Operators}

\begin{TTable}{lp{0.8\linewidth}}
\verb.==.&Checks if the values of two operands are equal or not, if yes then condition becomes true.\\
\verb.!=.&Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.\\
\verb.>.&Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.\\
\verb.<.&Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.\\
\verb.>=.&Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.\\
\verb.<=.&Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.\\
\end{TTable}

\subsection{Logical Operators}

\begin{TTable}{lp{0.8\linewidth}}
\verb.&&.&Called Logical AND operator. If both the operands are non-zero, then condition becomes true.\\
\verb.||.&Called Logical OR Operator. If any of the two operands is non-zero, then condition becomes true.\\
\verb.!.&Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true, then Logical NOT operator will make false.\\
\end{TTable}

\subsubsection{De Morgan's laws}

\begin{center}
\begin{tabular}{l}
\verb+!(a && b) == (!a || !b)+\\
\verb+!(a || b) == (!a && !b)+
\end{tabular}
\end{center}

\subsubsection{Application: XOR}

XOR is the exclusive or operation and different descriptions can be derived using De Morgan's laws.

\begin{center}
\begin{tabular}{ll}
\verb+(x||y) && !(x && y)+&x or y, and not both\\
\verb+(x||y) && (!x || !y)+&x or y, and one not\\
\verb+!(!x && !y) && !(x && y)+& not both and not none\\
\verb+!(!x && !y || x && y)+& not: none or both
\end{tabular}
\end{center}

\subsubsection{Short circuit evaluation}

The logical operators \verb+&&+ and \verb+||+ are left associative, thus evaluate the left operand first. If the result of the evaluation is clear after that, the right side is not evaluated at all. \textbf{Thus the simpler evaluation should always be on the left of the operator.}

\subsection{\ntn{Bitwise Operators}}

Bitwise operators work on bits and perform bit-by-bit operations. The truth tables for bitwise AND \verb.&., bitwise OR \verb.|. and bitwise exclusive OR (XOR) \verb.^. are:

\begin{TTable}{*{5}{c}}
\verb.p.&\verb.q.&\verb.p&q.&\verb.p|q.&\verb.p^q.\\
0&0&0&0&0\\
0&1&0&1&1\\
1&1&1&1&0\\
1&0&0&1&1\\
\end{TTable}

\begin{TTable}{lp{0.8\linewidth}}
\verb.&.&Binary AND Operator copies a bit to the result if it exists in both operands.\\
\verb.|.&Binary OR Operator copies a bit if it exists in either operand.\\
\verb.^.&Binary XOR Operator copies the bit if it is set in one operand but not both.\\
\verb.~.&Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.\\
\verb.<<.&Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.\\
\verb.>>.&Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.\\
\end{TTable}

\subsection{Assignment Operators}

\begin{TTable}{lp{0.8\linewidth}}
\verb.=.&Simple assignment operator, Assigns values from right side operands to left side operand.\\
\verb.+=.&Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand.\\
\verb.-=.&Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand.\\
\verb.*=.&Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand.\\
\verb./=.&Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand.\\
\verb.%=.&Modulus AND assignment operator, It takes modulus using two operands and assign the result to left operand.\\
\end{TTable}

\subsection{\ntn{Assignment Operators}}

\begin{TTable}{lp{0.8\linewidth}}
\verb.<<=.&Left shift AND assignment operator.\\
\verb.>>=.&Right shift AND assignment operator.\\
\verb.&=.&Bitwise AND assignment operator.\\
\verb.^=.&Bitwise exclusive OR and assignment operator.\\
\verb.|=.&Bitwise inclusive OR and assignment operator.\\
\end{TTable}

\subsection{Misc Operators}

\begin{TTable}{lp{0.8\linewidth}}
\verb.sizeof.&The sizeof operator returns the size of a variable in bytes. For example, sizeof(a), where ‘a’ is integer, and will return 4.\\
\verb.?X:Y.&If Condition is true then it returns value of X otherwise returns value of Y.\\
\verb.,.&The comma operator causes a sequence of operations to be performed. The value of the entire comma expression is the value of the last expression of the comma-separated list.\\
\verb+.+&The member operator \verb,., accesses a member of the operand on the left as specified by the operator on the right.\\
\verb.->.&The member operator \verb.->. is used to dereference the operand on the left and access one of its members indicated by the operand on the right.\\
Casts&Casting operators convert one data type to another. For example \verb.int(2,200). would return \verb.2..\\
\verb.&.&The address operator returns the address of a variable.\\
\verb.*.&The dereference operator returns the value the operand points to.\\
\end{TTable}

\subsection{Operator Precedence and Associativity}

\begin{TTable*}{|c|lp{0.5\linewidth}|l|}{\small}
P.&Operator&Description&Associativity\\\hline
1&\verb+::+&Scope resolution&\multirow{6}{*}{Left-to-right}\\\cline{1-3}
\multirow{5}{*}{2}&\verb.a++ a--.&Suffix/postfix increment and decrement&\\
&\verb.type() type{}.&Functional cast&\\
&\verb.a().&Function call&\\
&\verb.a[].&Subscript&\\
&\verb+. ->+&Member access&\\\hline
\multirow{9}{*}{3}&\verb.++a --a.&Prefix increment and decrement&\multirow{9}{*}{Right-to-left}\\
&\verb.+a -a.&Unary plus and minus&\\
&\verb.! ~.&Locigal NOT and bitwise NOT&\\
&\verb.(type).&C-style cast&\\
&\verb.*a.&Dereference&\\
&\verb.&a.&Adress-of&\\
&\verb.sizeof.&Size-of&\\
&\verb.new new[].&Dynamic memory allocation&\\
&\verb.delete delete[].&Dynamic memory deallocation&\\\hline
4&\verb+.* ->*+&Pointer-to-member&\multirow{11}{*}{Left-to-right}\\
5&\verb+a*b a/b a%b+&Multiplication, division, remainder&\\\cline{1-3}
6&\verb.a+b a-b.&Addition and subtraction&\\\cline{1-3}
7&\verb.<< >>.&Bitwise left shift and right shift&\\\cline{1-3}
8&\verb.<=>.&Three-way comparison operator&\\\cline{1-3}
9&\verb.< <= > >=.&Relational operators&\\\cline{1-3}
10&\verb.== !=.&Relational operators&\\\cline{1-3}
11&\verb.&.&Bitwise AND&\\\cline{1-3}
12&\verb.^.&Bitwise XOR&\\\cline{1-3}
13&\verb.|.&Bitwise OR&\\\cline{1-3}
14&\verb.&&.&Logical AND&\\\cline{1-3}
15&\verb.||.&Logical OR&\\\hline
\multirow{7}{*}{16}&\verb.a?b:c.&Ternary conditional&\multirow{7}{*}{Right-to-left}\\
&\verb.throw.&throw operator&\\
&\verb.=.&Direct assignment&\\
&\verb.+= -=.&\multirow{4}{*}{Compound assignments}&\\
&\verb.*= /= %=.&&\\
&\verb.<<= >>=.&&\\
&\verb.&= ^= |=.&&\\\hline
17&\verb.,.&Comma&Left-to-right\\
\end{TTable*}

\ifnum\conditionmacro=1
\subsubsection{How to use this table}

\begin{TPCpp}
cout<<a&&b;    //(cout<<a)&&b;

*p++           //*(p++);

a = b = c = d; //a = (b =(c = d)));

a + b - c;     //(a + b) - c;

delete ++*p;   //delete(++(*p))
\end{TPCpp}

\begin{enumerate}
\item By its precedence \verb+<<+ is evaluated before \verb+&&+.
\item By its precedence \verb.++. is evaluated before \verb.*..
\item Operators with the same precedence are evaluated based on their associativity. For right-to-left associative operators as \verb+=+, the evaluation proceeds from right to left.

Thus the assignments made in line 5 are in the order of their execution: \verb+c = d;+ which returns a reference to \verb+c+, \verb+b = c;+ which returns a reference to \verb+b+ and \verb+a = b;+.
\item Operators with the same precedence are evaluated based on their associativity. For left-to-right associative operators as \verb-+- and \verb+-+ the evaluation proceeds from left to right.
\item \verb.++()., \verb.*(). and \verb+delete+ have the same precedence, and are thus evaluated based on their associativity, which is right-to-left. Therefore \verb.++(). is evaluated after \verb.*(). and \verb+delete+ is evaluated last.
\end{enumerate}

If written badly expression can result in undefined behaviour:

\begin{TPCpp}
f(++i, ++i);
n = ++i + i;
b = ++a - a++;
\end{TPCpp}
\fi

\textbf{Avoid changing variables which are used again in the same expression.}

\section{Conditional Statements}

Conditional statements can be used to alter the flow of a program depending on set conditions.

\subsection{if}

The if command executes a single statement or a collection if a certain condition is evaluated as true.

\begin{TPCpp}
if (condition) single_statement;

if (condition) {
	statement1;
	statement2;
}
\end{TPCpp} 

\subsubsection{if...else}

The if else command executes statement1 if the condition is met and statement2 otherwise.

\begin{TPCpp}
if (condition) {
	statement1;
}
else {
	statement2;
}
\end{TPCpp} 

\subsubsection{if...else if... else}

Alternatively multiple conditions can be tested. Note that they are mutually exclusive, thus only the first of the cases, that evaluates as true is executed. The else if can be repeated.

\begin{TPCpp}
if (condition1) {

}
else if (condition2) {

}
else {

} 
\end{TPCpp}

\subsection{switch}

The switch statement is used to execute statements depending on the value of an expression. In doing so the expression is tested for equality with an integer (or enumeration type).

\begin{TPCpp}
switch (expression) {
	case 1 : cout << '1'; // prints "1"
	case 2 : cout << '2'; // then prints "2"
}

switch (expression) {
	case 1 : cout << '1'; // prints "1"
		break;	// then exits the switch
	case 2 : cout << '2';
		break;
	default : cout << "default";
}
\end{TPCpp}

Note that the cases are only executed mutually exclusively if ended with the break command, that exits the switch statement. Otherwise, as in the first case above all consecutive cases after the first met case are executed until break or the end of the switch is encountered. The default case is executed anytime it is reached. In other words, if none of the above cases has been met or if one has been met an no break has been reached. 

\subsection{? : Operator}

The \verb+? :+ operator can be understood as a short form of an if else command.

\begin{TPCpp}
a>b?a:b;

if(a>b) {
	return a;
}
else {
	return b;
}
\end{TPCpp}

The code snippets above accomplish exactly the same.

\section{Loop Types}

\subsection{while}

The while loop executes a set of statements as long as a set condition is evaluated as true.

\begin{TPCpp}
while (condition) {
	statement;
}
\end{TPCpp}

\subsection{for}

The for loop not only tests a condition but has additional functionality which is normally used to instantiate a counter variable and increment it. The three together define the loop duration in one line.

\begin{TPCpp}
for (init-statement; condition; expression){
	statement;
}

for (int i = 0; i < n ; i++){
	statement;
}

for (;condition;) {
	//equivalent to while(condition)
}
\end{TPCpp}

Optionally any of the three parts of the loop definition can be omitted. Leaving away the condition results in an infinite loop.

\subsection{do...while}

The do while loop executes its first iteration independent of the subsequently tested condition.

\begin{TPCpp}
do {
	statement
} while(condition);
\end{TPCpp}

\subsection{break continue}

In all of the loops above the loop control statements can be used to escape the loop (\verb+break+) to continue with the next iteration (\verb+continue+).

\begin{TPCpp}
while(true){
	if(condition){
		continue;
	}
	if(condition2){
		break;	
	}
}
\end{TPCpp}

\section{Functions}

\subsection{Structure}

\begin{TPCpp}
return_type function_name (parameter list) {
	body of the function
}
\end{TPCpp}

\begin{itemize}
\item \textbf{Return type: } A function may return a value. The \verb+return_type+ is the data type of that value. If the function should not return a value its \verb+return_type+ is set to \verb+void+.
\item \textbf{Function Name:} The function name can be any valid cpp identifier and will be used, together with the parameter list to call the function. Together, name and parameter list are called the function signature, which is unique for every function. \textbf{All non-void functions require a return statement!}
\item \textbf{Parameters:} The parameter variables are place-holders for the values that are passed to the function when it is called. On definition parameters must have type and name. Multiple parameters are separated with a comma. A function may have no parameters in which case a empty set of brackets is appended to the function name.
\item \textbf{Function Body:} The function body contains a set of statements that define what the function actually does.
\end{itemize}

\subsubsection{void}

\begin{itemize}
\item \verb+void+ is a fundamental type that has an empty range of values.
\item When used as a function return type void implies that the function does not return a value.
\item void functions do not need a return statement.
\item void functions end when encountering the end of the function body or when reaching the optional \verb+return;+
\end{itemize}

\subsection{Declaration and Definition}

A function declaration informs the compiler that there is a function with a certain signature. The declaration consists of return type, function name and parameter list, which can omit the parameter names if not directly follow by the definition.

\begin{TPCpp}
return_type function_name ( parameter list );

//for example
int max (int, int);
\end{TPCpp}

From that point on the function can be called within the code as long as it is followed by a proper definition at some point. The definition can follow the declaration directly:

\begin{TPCpp}
int min (int a, int b){
	return a<b?a:b;
}
\end{TPCpp}

Or come at some later point. Here we define the previously declared max function:

\begin{TPCpp}
int max (int a, int b){
	return a>b?a:b;
}
\end{TPCpp}

\subsubsection{return statement}

The return statement concludes any function. When it is reached the function ends immediately, passing the returned value to the program calling it initially. The value given to the return statement has to match the return type defined in the declaration of the function.

\subsection{Calling a function}

A function is called by directly following the signature in the function declaration. For example the above defined max function can be called as follows:

\begin{TPCpp}
int c = 2, d = 3;

cout<<"The maximum is "<<max(c,d)<<endl; 
\end{TPCpp}

Upon this call the values c and d that are passed to the function initialize the two parameters a and b in the body of the function.

\subsection{Function Arguments}

Depending on the way the parameters are passed to the function it behaves fundamentally different.

\subsubsection{Call by Value}

A call by value copies the values handed to the function into the parameters of the function. Therefore changes made to the parameters inside the function do not have an effect on the argument.

\begin{TPCpp}
void change(int a){
	a = 4;
}
\end{TPCpp}

\subsubsection{Call by Reference}

A call by reference makes the parameter a reference of the argument. Thus all changes made inside the function have the same effect on the argument.

\begin{TPCpp}
void change_ref(int & a){
	a = 4;
}
\end{TPCpp}

When calling the function there is no visible difference to a call by value:

\begin{TPCpp}
int main(){
	int b = 3;
	change(b); //no effect
	change_ref(b); //b = 4;
}
\end{TPCpp}

\subsubsection{Return by Reference}

A function can also return a reference. This however is only possible if the function has been called by reference in the first place. \textbf{Use call by read-only references instead of call by value for large data types to save effort.}

\begin{TPCpp}
int & increment (int & i){
	i = i + 1;
	//pass reference to variable that exists outside
	return i;
}
\end{TPCpp}

When trying to pass a reference to a local variable there will be a runtime error.

\begin{TPCpp}
int & increment (int no_reference){
	no_reference = no_reference + 1;
	//pass reference to local variable that 
	//will not persist beyond the function scope
	return no_reference;
}
\end{TPCpp}

The motivation to return by reference lies in the idea of processing the return value of a function further, possibly with another function that has to be called by reference. A good example is a concatenation of assignments.

\subsubsection{Call by Pointer}

A call by pointer makes the parameter a copy of the address of the argument. Equivalent to a call by reference the changes on the argument persist. Contrasting to it, the parameter has to be dereferenced since it is a pointer.

\begin{TPCpp}
void change_poi(int * a){
	*a = 4;
}
\end{TPCpp}

When calling the function there is a difference to a call by value, the function must be handed an address!

\begin{TPCpp}
int main(){
	int b = 3;
	change(b); // no effect
	change_poi(&b); // b = 4;
}
\end{TPCpp}

\subsubsection{Return by Pointer}

In contrast to a return by reference, a return by pointer is not restricted to functions that were called by a variable that exists outside the function scope. It is possible to allocate new memory and return a pointer to that memory.

\begin{TPCpp}
int * make_new_array (int Length){
	int * array_pointer;
	array_pointer = new int [Length];
	return array_pointer;
}
\end{TPCpp}

\subsubsection{\ntn{Default Values for Parameters}}

It is possible to define default values for function parameters. Those will be used when the corresponding argument is left blank when calling the function.

\begin{TPCpp}
void count_to_ten_or_more (int n = 10){
	for (int i = 0; i<n; i++){
		cout<<i+1<<" ";
	}
	cout<<endl;
}
\end{TPCpp}

With the default value set, the function above can be called as \verb+count_to_ten_or_more();+ which will result in a count to ten, or it can be given any argument of choice.

\subsection{Recursion}

It is possible to define function that call themselves:

\begin{TPCpp}
void f(){
	f(); //function calls itself endlessly
}
\end{TPCpp}

In order to make the call above work we need \textbf{progress}, i.e. each function call needs to accomplish a step in the correct \textbf{direction}, i.e. the recursion has to head towards a certain goal, a \textbf{termination}. These are the three essential components of a reasonable recursion.

\begin{TPCpp}
//POST: return value n!

unsigned int fac (unsigned int n)
{
	//termination condition
	if (n <= 1) return 1;
	
	//recursion with direction n->1
	return n * fac(n-1);
}
\end{TPCpp}

\begin{itemize}
\item Advantages:
\begin{itemize}
\item Simple solution of complex problems
\item Easily understandable code
\end{itemize}
\item Disadvantages:
\begin{itemize}
\item Stack overflow possible
\item Slower
\item More difficult debugging
\end{itemize}
\end{itemize}

\subsubsection{Call stack}

Recursive functions establish a whole stack of recursive calls until all ends are terminated. This stack can be nicely visualized:

\begin{TPCpp}
//POST: return value is the n-th
//Fibonacci number F(n)
unsigned int fib(const unsigned int n){
	if (n == 0) return 0;
	if (n == 1) return 1;
	return fib(n-1) + fib(n-2); //n>1
}
\end{TPCpp}

\begin{center}
\begin{tikzpicture}[level distance=10mm]
	\tikzstyle{every node}=[fill=white,draw=black,rectangle,inner sep=4pt]
	\tikzstyle{every child}=[fill=white,draw=black,rectangle,inner sep=4pt]
	\tikzstyle{level 1}=[set style ={{every child}+=[sibling distance=40mm]}]
	\tikzstyle{level 2}=[set style ={{every child}+=[sibling distance=20mm]}]
	\node{f(4)}
		child {node {f(3)}
				child{node {f(2)}
					child{node[fill=blue!20]{f(1)}}
					child{node[fill=blue!20]{f(0)}}
				}
				child{node[fill=blue!20] {f(1)}}
			}
		child{node {f(2)}
			child{node[fill=blue!20]{f(1)}} 
			child{node [fill=blue!20]{f(0)}}
			};		
\end{tikzpicture}
\end{center}

An iterative formulation of the above algorithm can also be established and nicely shows the advantage of its recursive brother:

\begin{TPCpp}
// POST: return value is the n-th Fibonacci number F(n)
unsigned int fib2 (const unsigned int n) {
if (n == 0) return 0;
if (n <= 2) return 1;
unsigned int a = 1; // F_1
unsigned int b = 1; // F_2
for (unsigned int i = 3; i <= n; ++i) {
unsigned int a_prev = a; // F_i-2
a = b; // F_i-1
b += a_prev; // F_i-1 += F_i-2 -> F_i
}
return b;
}
\end{TPCpp}

\subsection{\ntn{Inline Functions}}

\section{Arrays}

Arrays are used to save a previously known number of data points of the same type.

\begin{TPCpp}
int list_1 [4]; // [r1 r2 r3 r4]
int list_2 [ ] = {1,2,3,4}; // [1 2 3 4]
int list_3 [4] = {1}; // [1 0 0 0]
list_1 [0] = 1;
//list_1 [4] = 5; // segmentation fault
\end{TPCpp}

\begin{itemize}
\item Arrays are declared with type, name and the length in square brackets. Uninitialized arrays contain random values. (\verb+list_1+)
\item Arrays with undefined length need to be initialized directly such that the length can be determined. (\verb+list_2+)
\item Arrays with a short initialization will fill up with zeros. (\verb+list_3+)
\item Array indexing starts with 0.
\item Accessing out-of-bound values results in undefined behaviour.
\end{itemize}

\subsection{Arrays and Pointers}

The name of an array can be understood as a pointer to the first element of the array.

\begin{TPCpp}
int list_1 [4] = {1,2,3,4};
int list_2 [1];
// list_1 = list_2; // error
int * list_pointer_1 = list_1;
int * list_pointer_2 = &list_1[0];
list_1[1]; // value: 2
list_pointer_1[1]; //value: 2
list_pointer_2[1]; //value: 2
*(list_1 + 1); //value: 2
\end{TPCpp}

\begin{itemize}
\item The name of an array is a pointer that is not allowed to be changed.
\item A pointer to the name of an array is equivalent with a pointer to the address of the first element of the same array.
\item The access operator \verb+[]+ works on the array name as well as on a pointer on the array.
\item The access operator is equivalent with the increment and subsequent dereferencing of a pointer to the array.
\end{itemize}

Based on the knowledge that arrays are saved with a pointer to the first element of the allocated memory dynamic arrays can be created:

\begin{TPCpp}
int n;
cin >> n;
int * dynamic_array = new int [n];
\end{TPCpp}

\begin{itemize}
\item The dynamically allocated array can now be used exactly the same as a static array.
\item The dynamic array needs to be deleted with \verb+delete [] dynamic_array+ in order not to create memory leaks!
\end{itemize}

\subsection{Multidimensional Arrays}

Arrays can have more than one dimension, and can thus also be used to represent matrices or tables. 

\begin{TPCpp}
//2 elements, each an array of length 3
//uninitialized
int a_1[2][3];
//initialized, size specified
int a[2][3] = {
	{1,2,3},{2,6,3}
};
//initialized, size partially specified
int a[][3] = {
	{1,3,4},{2,3,4},{13 3 2}
};
\end{TPCpp}

As described in the last example it is possible to leave the first dimension unspecified if a direct initialization follows. Exactly as for simple arrays the length is determined automatically. This however does not work for the second dimension.
The array above is saved in the memory as seen below:

\includegraphics[width=\linewidth]{Pictures/2DArray}

\subsection{Passing arrays as arguments}

Since we know that arrays are basically pointers to memory it is possible to pass an array to the function by simple giving it a pointer to the first element of the array. Using references however we can prevent the decaying of the array-name (which remembers the length of the array if defined statically) by passing a reference to the array name as follows:

\begin{TPCpp}
void some_array_function(int pointer []){
	//...
}

void nice_array_function(int (&arrayname) [10]{
	//...
}
\end{TPCpp}

The first function will accept any pointer and will not preserve the knowledge of the length of the array. The second function is able to determine whether the argument is actually an array of the specified length and will preserve this information, but has the drawback that it only works for that specific length.

\section{vector}

The vector class is a member of the standard library and improves on many of the issues observed with arrays. Vectors are implemented as a template and thus need a type specification in angled brackets.

\begin{TPCpp}
#include <vector>

std::vector<int> int_vector;
\end{TPCpp}

The basic functionality of vector can be seen here, \easyurl{read}{http://www.cplusplus.com/reference/vector/vector/} for more details.

\begin{TPCpp}
//create a bool vector with length 100
//all entries set to false
std::vector<bool> status(100,false);

//create a copy of an existing vector
std::vector<bool> copy(status);

//access entries
copy[0]; // first entry
copy.at(0); // first entry
copy.push_back(true); // append entry: true
copy.pop_back(); //delete last element
\end{TPCpp}

\subsection{Multidimensional vectors}

Multidimensional vectors are similar to multidimensional arrays in functionality. The declaration is a bit more complicated:

\begin{TPCpp}
using namespace std;
vector < vector < int > > a (n, vector<int>(m));
\end{TPCpp}

The above declaration describes a vector of int vectors. The initialization defines the dimensions as follows: The outer vector is of length n and contains vectors of lengths m.

\subsection{Access}

There exist different methods of accessing the elements of vectors.

\begin{enumerate}
\item \textbf{Random access:} The concept of random access allows accessing any element of a vector with the same effort.

\begin{TPCpp}
//long array (syntax simplified!)
int a [] = {1,2,3,4,5,6,...,100};

//random access:
a[33]; // identical to: *(a+33);
\end{TPCpp}

The random access operation as described above requires a single addition and an implicit multiplication automatically made through pointer arithmetic when adding a number to a pointer.

This access method is really flexible but also costly.
\item \textbf{Sequential access:} This is where sequential access shines, which only requires a simple addition for getting to the next element in an array, but is less flexible since it can only go back an forth in steps of one. Sequential access can be implemented as follows:

\begin{TPCpp}
int a[5] = {1,2,3,4,5};
for (int* p = a; p < a+5; ++P)
	cout<<*p<<" ";
	
//For vectors iterators can be used

\end{TPCpp}
\end{enumerate}

\subsection{Iterators}

Since vectors allocate memory differently than arrays they cannot simply be traversed using a pointer. For that reason and to have an interface for advanced functionality vectors have iterators pointing to their elements.

\begin{TPCpp}
std::vector<int>::const_iterator

std::vector<int>::iterator
\end{TPCpp}

The first version can be used for non-mutating access. It is analogue to a \verb+const int*+ for arrays. The second version allows changing of the elements it points to. 

\begin{TPCpp}
std::vector<int> vec;
vec.push_back(1);
vec.push_back(2);
std::vector<int>::iterator it = vec.begin();

while(it<vec.end()) {
	cout<<*it<<endl;
	it++;
}
\end{TPCpp}

In the above example the member functions \verb+begin()+ and \verb+end()+ are used to initialize and constrain an iterator going through the vector. Access to pointed-to elements and increment of the iterator works just like it does using pointers.

\subsection{Passing vectors to functions}

By convention of the standard library vectors are passed to functions using two iterators, one to the beginning of a valid part of the vector to be passed and  a second to the ending of the same. This can of course include the whole vector but includes the flexibility of only processing a part of it.

\begin{TPCpp}
std::vector<double> d(100,0);
std::fill(d.begin(),d.end(),1);
\end{TPCpp}

\section{Strings}

\subsection{C-style character string}

One possibility to save a string is using an array of chars. By convention character arrays are terminated with \verb+\0+. This serves the purpose of marking the end of a string.

\begin{TPCpp}
//initialisation with string literal
char text = "bool";
//equivalent to:
char text = {'b','o','o','l','\0'};
\end{TPCpp}

\subsection{string}

The modern alternative to char arrays is the \easyurl{string class}{http://www.cplusplus.com/reference/string/string/} in the standard library. It serves the same purpose as the character array but makes handling strings a lot easier. For instance the length of a string does not have to be known at compiletime and can thus also change during runtime.

\begin{TPCpp}
#include <string>
std::string text1 = "bool";
text1.length(); //A string knows its length
//initialize with variable length n
//and fill with 'a'
std:string text2 (n, 'a');
//string understands comparisons
//and many other operations
text1 == text2; 
\end{TPCpp}

\section{Pointers}

\section{References}

A reference is another name for an already existing variable. It has to be initialized when declared and cannot refer to another variable afterwards. \textbf{The object referred to has to exist at least as long as its reference!}

\begin{TPCpp}
int i = 1;
int & ref_to_i = i;
// int & ref_to_nothing; //not allowed!
\end{TPCpp}

In c++ a reference declaration consists of the type which is to referred to, the \verb+&+ operator and the name of the reference, followed by an assignment of a valid L-value. After initialisation \verb+ref_to_i+ can be used exactly the same as \verb+i+!

\begin{TPCpp}
//int & h = 3; // not allowed!
const int & i = 7;
\end{TPCpp}

Only \verb+const+ references are allowed to point to R-values!

\begin{TPCpp}
const int n = 5;
// int & i = n; // not allowed
const int & i = n; // allowed, read only
\end{TPCpp}

Only \verb+const+ references can refer to constant variables.
\section{Input/Output}

\section{struct}

\section{class}

\subsection{Class Members}

\subsection{Class Access Modifiers}

\subsection{Constructor and Destructor}

\subsection{Copy Constructor}

\subsection{friend}

\subsection{this}

\subsection{Static Members}

\section{Inheritance}

\subsection{Access Control and Inheritance}

\section{Overloading}

\subsection{Function overloading}

\subsection{Operator overloading}

\subsubsection{Overloadable operators}

\section{Polymorphism}

\section{Dynamic Memory}

\section{Namespaces}

\section{Templates}

\section{Signal Handling}

\section{Standard Template Library}

\section{Libraries}

\subsection{iostream}

\subsection{math}

\subsection{ctime}







\end{multicols*}
\end{document}
